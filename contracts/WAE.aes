@compiler >= 6

include "Option.aes"
include "String.aes"
include "./interfaces/IAEX9Minimal.aes"
include "./lib/Utils.aes"


contract WAE =
    type owner = address
    type spender = address

    record state =
        { balance_of: map(owner, int)
        , allowance: map(owner, map(spender,int))
        }

    entrypoint init() = {
          balance_of= {}
        , allowance = {}
        }

    //------------------------------------------------------------------------------
    // viewers
    //------------------------------------------------------------------------------

    entrypoint total_supply() = Contract.balance
    entrypoint total_supply_str() = Int.to_str(Contract.balance)


    entrypoint meta_info(): IAEX9Minimal.meta_info = {
          name = "Wrapped Aeternity",
          symbol = "WAE",
          decimals = 18
        }

    entrypoint balance(address: address): option(int) =
        //NOTE: tests are based on 0 not on null/undefined,
        //we make this hack replacing None with Some(0)
        Some(Map.lookup_default(address,state.balance_of,0))

    entrypoint allowance(accounts: IAEX9Minimal.allowance_accounts): option(int) =
        let (owner,spender) = (accounts.from_account,accounts.for_account)
        let spenderA = Map.lookup_default(owner,state.allowance,{})
        Map.lookup(spender,spenderA)

    entrypoint allowance_unfolded(
             from_account: address,
             for_account: address
        ): option(int) = allowance({from_account = from_account, for_account = for_account})

    //------------------------------------------------------------------------------
    // stateful ones
    //------------------------------------------------------------------------------
    payable stateful entrypoint deposit(): unit =
        put(state{balance_of @ b = b { [ Call.caller = 0] @ value = value + Call.value} })
        Chain.event( Deposit(Call.caller, Call.value) )

    payable stateful entrypoint deposit_to(to: address): unit =
        put(state{balance_of @ b = b { [ to = 0] @ value = value + Call.value} })
        Chain.event( Deposit(Call.caller, Call.value) )
        Chain.event( Transfer( Call.caller, to, Call.value ) )

    stateful entrypoint withdraw(amount: int): unit =
        let caller_balance: int = Map.lookup_default(Call.caller,state.balance_of,0)
        require(caller_balance >= amount, "WAE: LOW_BALANCE")
        put(state{balance_of @ b = b { [ Call.caller ] = caller_balance - amount} })
        Chain.spend( Call.caller,amount )
        Chain.event( Withdrawal(Call.caller, amount) )

    stateful entrypoint create_allowance(guy: address, amount: int): unit =
        put( state{allowance @ a = a{ [Call.caller = {} ] @ p = p { [guy] = amount }}})
        Chain.event(Allowance(Call.caller, guy, amount))


    stateful entrypoint transfer(dst: address , amount: int): unit =
        transfer_allowance(Call.caller, dst, amount)

    stateful entrypoint transfer_allowance(src: address, dst: address, amount: int) =
        let src_balance = Map.lookup_default(src,state.balance_of,0)
        require(src_balance >= amount, "WAE: LOW_BALANCE")

        if (src != Call.caller)
            let src_allowance_map = Map.lookup_default(src,state.allowance,{})
            let src_allowance = Map.lookup_default(Call.caller,src_allowance_map,0)
            require(src_allowance >= amount, "WAE: LOW_ALLOWANCE")
            put( state{ allowance @ a = a { [src = {}] @ s = s { [Call.caller] @ p = p - amount}}})

        put( state { balance_of @ b = b {
                [ src ] @ s = s - amount,
                [ dst = 0 ] @ d = d + amount
            } })
        Chain.event( Transfer( src, dst, amount ) )


    datatype event
        = Transfer(address /*indexed from*/, address /*indexed to*/, int /*value*/)

        | Allowance(address /*indexed owner*/, address /*indexed spender*/, int /*value*/)

        | Deposit(address /*indexed dst*/, int /*ae*/)

        | Withdrawal(address /*indexed src*/, int /*amount*/)



