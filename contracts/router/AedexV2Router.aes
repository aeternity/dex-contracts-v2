@compiler >= 6

include "../interfaces/router/IWAE.aes"
include "../interfaces/IAedexV2Factory.aes"
include "../interfaces/IAEX9Minimal.aes"
include "../interfaces/IAedexV2Callback.aes"
include "../interfaces/IAedexV2Pair.aes"
include "../lib/router/AedexV2Library.aes"

include "Option.aes"

payable contract AedexV2Router =
    record state = {
              factory: IAedexV2Factory
            , wae: IWAE
            , wae_aex9: IAEX9Minimal
            }
    /*datatype event = SomeEvent(int)*/

    type amountA = int
    type amountB = int
    type amountToken = int
    type amountAE = int
    type liquidity = int

    //TODO: can we restrict from whom should this contract receive AE?
    /*receive() external payable {*/
        /*assert(msg.sender == WETH) // only accept ETH via fallback from the WETH contract*/
    /*}*/

    //TODO: add factory and WAE
    entrypoint init( factory: IAedexV2Factory, wae: IWAE, wae_aex9: IAEX9Minimal) =
        require(wae.address == wae_aex9.address,"AedexV2Router: DIFFERENT_WAE_ADDRESSES")
        {   factory  = factory
          , wae      = wae
          , wae_aex9 = wae_aex9
          }

    entrypoint balance() = Contract.balance
    entrypoint factory() = state.factory
    entrypoint wae() = state.wae
    entrypoint wae_aex9() = state.wae_aex9

    // **** ADD LIQUIDITY ****

    //just creates the pair if it is the case and calculates the amount
    // based on parameters and pair reserves
    stateful function _add_liquidity(
          tokenA: IAEX9Minimal
        , tokenB: IAEX9Minimal
        , amountADesired: int
        , amountBDesired: int
        , amountAMin: int
        , amountBMin: int
        ): (amountA *  amountB) =
        let factory = state.factory
        // create the pair if it doesn't exist yet
        if( Option.is_none( factory.get_pair(tokenA, tokenB) ))
           factory.create_pair(tokenA,tokenB,None)
           ()
        let (reserveA,reserveB) = AedexV2Library.get_reserves( factory, tokenA, tokenB )

        if (reserveA == 0 && reserveB == 0)
            (amountADesired, amountBDesired)
        else
            let amountBOptimal = AedexV2Library.quote(amountADesired, reserveA, reserveB)
            if (amountBOptimal =< amountBDesired)
                require(amountBOptimal >= amountBMin, "AedexV2Router: INSUFFICIENT_B_AMOUNT")
                (amountADesired, amountBOptimal)
            else
                let amountAOptimal = AedexV2Library.quote(amountBDesired, reserveB, reserveA)
                require(amountAOptimal =< amountADesired, "AedexV2Router: OPTIMAL_GREATER_THEN_DESIRED")
                require(amountAOptimal >= amountAMin, "AedexV2Router: INSUFFICIENT_A_AMOUNT")
                (amountAOptimal, amountBDesired)

    stateful entrypoint add_liquidity(
              tokenA: IAEX9Minimal
            , tokenB: IAEX9Minimal
            , amountADesired: int
            , amountBDesired: int
            , amountAMin: int
            , amountBMin: int
            , to: address
            , deadline: int
        ): (amountA * amountB * liquidity) =
        ensure_deadline(deadline)
        let (amountA, amountB) = _add_liquidity(
                tokenA, tokenB,
                amountADesired, amountBDesired,
                amountAMin, amountBMin
                )
        //getting pair and transfer to its address the tokens
        let pair: IAedexV2Pair = AedexV2Library.pair_for( state.factory, tokenA, tokenB )
        tokenA.transfer_allowance( Call.caller,pair.address,amountA )
        tokenB.transfer_allowance( Call.caller,pair.address,amountB )
        ( amountA, amountB, pair.mint(to) )

    payable stateful entrypoint add_liquidity_ae(
        token: IAEX9Minimal
        , amountTokenDesired: int
        , amountTokenMin: int
        , amountAEMin: int
        , to: address
        , deadline: int
        ):  (amountToken * amountAE * liquidity) =
        let (wae_aex9,wae,_) = trio(deadline)
        let (amountToken, amountAE) = _add_liquidity(
                token, wae_aex9,
                amountTokenDesired, Call.value,
                amountTokenMin, amountAEMin
                )
        let pair: IAedexV2Pair = AedexV2Library.pair_for(state.factory, token, wae_aex9)
        token.transfer_allowance(Call.caller, pair.address, amountToken)

        wae.deposit(value=amountAE)
        wae.transfer(pair.address,amountAE)
        let liquidity = pair.mint(to)
        if (Call.value > amountAE)
            Chain.spend(Call.caller,Call.value - amountAE) // refund dust ae, if any
        (amountToken,amountAE,liquidity)

    // **** REMOVE LIQUIDITY ****
    stateful entrypoint remove_liquidity(
              tokenA: IAEX9Minimal
            , tokenB: IAEX9Minimal
            , liquidity: int
            , amountAMin: int
            , amountBMin: int
            , to: address
            , deadline: int
        ): (amountA * amountB) =
        ensure_deadline(deadline)
        let pair: IAedexV2Pair = AedexV2Library.pair_for(state.factory, tokenA, tokenB)
        pair.transfer_allowance(Call.caller, pair.address, liquidity) // send liquidity to pair
        let burnRet = pair.burn(to)
        let (amount0, amount1) = (burnRet.amount0,burnRet.amount1)
        let (token0,_) = AedexV2Library.sort_tokens(tokenA, tokenB)
        let (amountA, amountB) = if (tokenA == token0) (amount0, amount1) else (amount1, amount0)
        require(amountA >= amountAMin, "AedexV2Router: INSUFFICIENT_A_AMOUNT")
        require(amountB >= amountBMin, "AedexV2Router: INSUFFICIENT_B_AMOUNT")
        (amountA,amountB)

    stateful entrypoint remove_liquidity_ae(
            token: IAEX9Minimal
            , liquidity: int
            , amountTokenMin: int
            , amountAEMin: int
            , to: address
            , deadline: int
        ): (amountToken * amountAE) =
        let (wae_aex9,wae,_) = trio(deadline)
        let (amountToken, amountAE) = remove_liquidity(
                token, wae_aex9,
                liquidity,
                amountTokenMin, amountAEMin,
                Contract.address,
                deadline
                )
        token.transfer(to,amountToken)
        //TODO: be sure is the right thing to do
        wae.withdraw(amountAE)
        Chain.spend(to,amountAE)
        (amountToken,amountAE)

    stateful entrypoint remove_liquidity_with_permit(
            tokenA: IAEX9Minimal
            , tokenB: IAEX9Minimal
            , liquidity: int
            , amountAMin: int
            , amountBMin: int
            , to: address
            , deadline: int
            , approveMax: bool
        ): (amountA * amountB) =
        let pair: IAedexV2Pair = AedexV2Library.pair_for(state.factory, tokenA, tokenB)
        // TODO: decide a max, in solidity is uint(-1)
        let max = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
        let value = if(approveMax) max else liquidity
        //TODO: permit is not yet implemented
        pair.permit(Call.caller,Contract.address,value,deadline)
        remove_liquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline)

    stateful entrypoint remove_liquidity_ae_with_permit(
              token: IAEX9Minimal
            , liquidity: int
            , amountTokenMin: int
            , amountAEMin: int
            , to: address
            , deadline: int
            , approveMax: bool
        ): (amountToken * amountAE) =
        let wae_aex9 = state.wae_aex9
        let wae = state.wae
        let pair = AedexV2Library.pair_for(state.factory, token, wae_aex9)
        // TODO: decide a max, in solidity is uint(-1)
        let max = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
        let value = if(approveMax) max else liquidity
        //TODO: permit is not yet implemented
        pair.permit(Call.caller, Contract.address, value, deadline )
        remove_liquidity_ae(token, liquidity, amountTokenMin, amountAEMin, to, deadline)

    // **** SWAP ****
    // requires the initial amount to have already been sent to the first pair
    stateful function _swap(
            amounts: list(int)
            , path: list(IAEX9Minimal)
            , _to: address
            , factory: IAedexV2Factory  // we pass it as parameter to save multiple state lookups
            , callback: option(IAedexV2Callback)
        ): unit =
        switch((path,amounts))
            (input::output::_path,_::amountOut::_amounts) =>
                let (token0,_) = AedexV2Library.sort_tokens(input,output)
                let (amount0Out, amount1Out) = if (input == token0) (0, amountOut) else (amountOut, 0)
                let to = switch(_path)
                            [] => _to
                            (nexOutput::_) => AedexV2Library.pair_for(factory,output,nexOutput).address
                let pair: IAedexV2Pair = AedexV2Library.pair_for(factory,input,output)

                pair.swap(amount0Out, amount1Out, to,callback)
                _swap(amountOut::_amounts,output::_path,_to,factory,callback)
            (_::_::_,_::[]) => _invalidAmounts()
            (_::_::_,[]) => _invalidAmounts()
            (_,_) => ()

    /*datatype event*/
        /*= TestEvent(int)*/
        /*| Test2Event(int)*/
    stateful entrypoint swap_exact_tokens_for_tokens(
              amount_in: int
            , amount_out_min: int
            , path: list(IAEX9Minimal)
            , to: address
            , deadline: int
            , callback: option(IAedexV2Callback)
        ): list(int) =
        ensure_deadline(deadline)
        let factory = state.factory
        let amounts = AedexV2Library.get_amounts_out(factory, amount_in, path)
        require( last(amounts) >= amount_out_min,
                 "AedexV2Router: INSUFFICIENT_OUTPUT_AMOUNT"
               )
        /*Chain.event(SomeEvent)*/
        List.get(0,path).transfer_allowance(
            Call.caller,
            first_pair(factory,path).address,
            List.get(0,amounts)
            )
        _swap(amounts, path, to, factory, callback)
        amounts

    stateful entrypoint swap_tokens_for_exact_tokens(
              amount_out: int
            , amount_in_max: int
            , path: list(IAEX9Minimal)
            , to: address
            , deadline: int
            , callback: option(IAedexV2Callback)
        ): list(int) =
        ensure_deadline(deadline)
        let factory = state.factory
        let amounts = AedexV2Library.get_amounts_in(factory, amount_out, path)
        require(List.get(0,amounts) =< amount_in_max, "AedexV2Router: EXCESSIVE_INPUT_AMOUNT")
        List.get(0,path).transfer_allowance(
            Call.caller,
            first_pair(factory,path).address,
            List.get(0,amounts)
            )
        _swap(amounts, path, to, factory, callback)
        amounts

    payable stateful entrypoint swap_exact_ae_for_tokens(
              amount_out_min: int
            , path: list(IAEX9Minimal)
            , to: address
            , deadline: int
            , callback: option(IAedexV2Callback)
        ): list(int) =
        let (wae_aex9,wae,factory) = trio(deadline)
        require(first(path) == wae_aex9, "AedexV2Router: INVALID_PATH")
        let amounts = AedexV2Library.get_amounts_out(factory, Call.value, path)
        require(last(amounts) >= amount_out_min,
                 "AedexV2Router: INSUFFICIENT_OUTPUT_AMOUNT")
        wae.deposit(value=List.get(0,amounts))
        let pair = first_pair(factory,path)
        //TODO: is bool ok for transfer?
        wae.transfer(pair.address,List.get(0,amounts))
        _swap(amounts, path, to, factory, callback )
        amounts

    stateful entrypoint swap_tokens_for_exact_ae(
              amount_out: int
            , amount_in_max: int
            , path: list(IAEX9Minimal)
            , to: address
            , deadline: int
            , callback: option(IAedexV2Callback)
        ): list(int) =
        let (wae_aex9,wae,factory) = trio(deadline)
        require(last(path) == wae_aex9, "AedexV2Router: INVALID_PATH")
        let amounts = AedexV2Library.get_amounts_in(factory, amount_out, path)
        require(List.get(0,amounts) =< amount_in_max, "AedexV2Router: EXCESSIVE_INPUT_AMOUNT")
        List.get(0,path).transfer_allowance(
            Call.caller,
            first_pair(factory,path).address,
            List.get(0,amounts)
            )
        _swap(amounts, path, Contract.address, factory, callback)
        let last_amount = last(amounts)
        //TODO: be sure is the right thing to do
        wae.withdraw(last_amount)
        Chain.spend(to,last_amount)
        amounts

    stateful entrypoint swap_exact_tokens_for_ae(
          amount_in: int
        , amount_out_min: int
        , path: list(IAEX9Minimal)
        , to: address
        , deadline: int
        , callback: option(IAedexV2Callback)
        ): list(int) =
        let (wae_aex9,wae,factory) = trio(deadline)
        require(last(path) == wae_aex9, "AedexV2Router: INVALID_PATH")
        let amounts = AedexV2Library.get_amounts_out(factory, amount_in, path)
        require(last(amounts)>= amount_out_min, "AedexV2Router: INSUFFICIENT_OUTPUT_AMOUNT")
        first(path).transfer_allowance(
            Call.caller,
            first_pair(factory,path).address,
            first(amounts)
            )
        _swap(amounts, path, Contract.address, factory, callback)
        let last_amount = last(amounts)
        //TODO: be sure is the right thing to do
        wae.withdraw(last_amount)
        Chain.spend(to,last_amount)
        amounts

    payable stateful entrypoint swap_ae_for_exact_tokens(
              amount_out: int
            , path: list(IAEX9Minimal)
            , to: address
            , deadline: int
            , callback: option(IAedexV2Callback)
        ): list(int) =
        let (wae_aex9,wae,factory) = trio(deadline)
        require(first(path) == wae_aex9, "AedexV2Router: INVALID_PATH")
        let amounts = AedexV2Library.get_amounts_in(factory, amount_out, path)
        let fst_amount = first(amounts)
        require(first(amounts) =< Call.value, "AedexV2Router: EXCESSIVE_INPUT_AMOUNT")
        wae.deposit(value=fst_amount)
        let fst_pair = first_pair(factory,path)
        wae.transfer(fst_pair.address,fst_amount)
        _swap(amounts, path, to, factory, callback)
        if (Call.value > fst_amount)
            Chain.spend(Call.caller,Call.value - fst_amount) // refund dust ae, if any
        amounts

    // **** LIB EXPOSURE ****
    entrypoint quote(amountA, reserveA, reserveB ) =
        AedexV2Library.quote(amountA, reserveA, reserveB)

    entrypoint get_amount_out( amount_in, reserve_in, reserve_out) =
        AedexV2Library.get_amount_out( amount_in, reserve_in, reserve_out)

    entrypoint get_amount_in( amount_out, reserve_in, reserve_out) =
        AedexV2Library.get_amount_in( amount_out, reserve_in, reserve_out)

    function get_amounts_out( amount_in , path) =
        AedexV2Library.get_amounts_out(state.factory, amount_in , path)

    function get_amounts_in( amount_out , path) =
        AedexV2Library.get_amounts_in(state.factory, amount_out , path)

    // **** UTILS ****
    function first_pair( factory: IAedexV2Factory, path: list(IAEX9Minimal)): IAedexV2Pair =
        AedexV2Library.pair_for(factory, List.get(0,path), List.get(1,path))

    function last(xs: list('a)): 'a = List.get(List.length(xs)-1,xs)
    function first(xs: list('a)): 'a = List.get(0,xs)

    function trio(deadline: int) =
        ensure_deadline(deadline)
        (state.wae_aex9,state.wae,state.factory)

    function ensure_deadline(deadline: int) =
        require(deadline >= Chain.timestamp, "AedexV2Router: EXPIRED")
    function _invalidAmounts() =
        abort("AedexV2Router: AMOUNT_LIST_IS_SHORTER")

