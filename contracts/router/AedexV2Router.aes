@compiler >= 6

include "../interfaces/router/IWAE.aes"
include "../interfaces/IAedexV2Factory.aes"
include "../interfaces/IAEX9Minimal.aes"
include "../interfaces/IAedexV2Callback.aes"
include "../interfaces/IAedexV2Pair.aes"
include "../lib/router/AedexV2Library.aes"

include "Option.aes"

payable contract AedexV2Router =
    record state = {
              factory: IAedexV2Factory
            , wae: IWAE
            , wae_aex9: IAEX9Minimal
            }

    type amount_a = int
    type amount_b = int
    type amount_token = int
    type amount_ae = int
    type liquidity = int

    //TODO: can we restrict from whom should this contract receive AE?
    /*receive() external payable {*/
        /*assert(msg.sender == WETH) // only accept ETH via fallback from the WETH contract*/
    /*}*/

    entrypoint init( factory: IAedexV2Factory, wae: IWAE, wae_aex9: IAEX9Minimal) =
        require(wae.address == wae_aex9.address,"AedexV2Router: DIFFERENT_WAE_ADDRESSES")
        {   factory  = factory
          , wae      = wae
          , wae_aex9 = wae_aex9
          }

    entrypoint balance() = Contract.balance
    entrypoint factory() = state.factory
    entrypoint wae() = state.wae
    entrypoint wae_aex9() = state.wae_aex9

    // **** ADD LIQUIDITY ****

    //just creates the pair if it is the case and calculates the amount
    // based on parameters and pair reserves
    function _add_liquidity(
          token_a: IAEX9Minimal
        , token_b: IAEX9Minimal
        , amount_a_desired: int
        , amount_b_desired: int
        , amount_a_min: int
        , amount_b_min: int
        , min_liquidity: int
        ): (amount_a *  amount_b) =
        let factory = state.factory
        // create the pair if it doesn't exist yet
        if( Option.is_none( factory.get_pair(token_a, token_b) ))
           factory.create_pair(token_a,token_b,min_liquidity,None)
           ()
        let (reserve_a,reserve_b) = AedexV2Library.get_reserves( factory, token_a, token_b )

        if (reserve_a == 0 && reserve_b == 0)
            (amount_a_desired, amount_b_desired)
        else
            let amount_b_optimal = AedexV2Library.quote(amount_a_desired, reserve_a, reserve_b)
            if (amount_b_optimal =< amount_b_desired)
                require(amount_b_optimal >= amount_b_min, "AedexV2Router: INSUFFICIENT_B_AMOUNT")
                (amount_a_desired, amount_b_optimal)
            else
                let amount_a_optimal = AedexV2Library.quote(amount_b_desired, reserve_b, reserve_a)
                require(amount_a_optimal =< amount_a_desired, "AedexV2Router: OPTIMAL_GREATER_THEN_DESIRED")
                require(amount_a_optimal >= amount_a_min, "AedexV2Router: INSUFFICIENT_A_AMOUNT")
                (amount_a_optimal, amount_b_desired)

    stateful entrypoint add_liquidity(
              token_a: IAEX9Minimal
            , token_b: IAEX9Minimal
            , amount_a_desired: int
            , amount_b_desired: int
            , amount_a_min: int
            , amount_b_min: int
            , to: address
            , min_liquidity: int // the minimum liquidity constant for the pair 
                                 // in case the pair is not yet created
            , deadline: int
        ): (amount_a * amount_b * liquidity) =
        require_deadline(deadline)
        let (amount_a, amount_b) = _add_liquidity(
                token_a, token_b,
                amount_a_desired, amount_b_desired,
                amount_a_min, amount_b_min,
                min_liquidity
                )
        //getting pair and transfer to its address the tokens
        let pair: IAedexV2Pair = AedexV2Library.pair_for( state.factory, token_a, token_b )
        token_a.transfer_allowance( Call.caller,pair.address,amount_a )
        token_b.transfer_allowance( Call.caller,pair.address,amount_b )
        let minted_liquidity = pair.mint(to)
        ( amount_a, amount_b, minted_liquidity )

    payable stateful entrypoint add_liquidity_ae(
        token: IAEX9Minimal
        , amount_token_desired: int
        , amount_token_min: int
        , amount_ae_min: int
        , to: address
        , min_liquidity: int // the minimum liquidity constant for the pair 
                             // in case the pair is not yet created
        , deadline: int
        ):  (amount_token * amount_ae * liquidity) =
        require_deadline(deadline)
        let (wae_aex9,wae) = (state.wae_aex9,state.wae)
        let (amount_token, amount_ae) = _add_liquidity(
                token, wae_aex9,
                amount_token_desired, Call.value,
                amount_token_min, amount_ae_min,
                min_liquidity
                )
        let pair: IAedexV2Pair = AedexV2Library.pair_for(state.factory, token, wae_aex9)
        token.transfer_allowance(Call.caller, pair.address, amount_token)

        wae.deposit_to(pair.address,value=amount_ae)
        let liquidity = pair.mint(to)
        if (Call.value > amount_ae)
            Chain.spend(Call.caller,Call.value - amount_ae) // refund dust ae, if any
        (amount_token,amount_ae,liquidity)

    // **** REMOVE LIQUIDITY ****
    stateful entrypoint remove_liquidity(
              token_a: IAEX9Minimal
            , token_b: IAEX9Minimal
            , liquidity: int
            , amount_a_min: int
            , amount_b_min: int
            , to: address
            , deadline: int
        ): (amount_a * amount_b) =
        require_deadline(deadline)
        let pair: IAedexV2Pair = AedexV2Library.pair_for(state.factory, token_a, token_b)
        pair.transfer_allowance(Call.caller, pair.address, liquidity) // send liquidity to pair
        let burn_ret = pair.burn(to)
        let (token0,_) = AedexV2Library.sort_tokens(token_a, token_b)
        let (amount_a, amount_b) = if (token_a == token0) (burn_ret.amount0, burn_ret.amount1)
                                   else (burn_ret.amount1, burn_ret.amount0)
        require(amount_a >= amount_a_min, "AedexV2Router: INSUFFICIENT_A_AMOUNT")
        require(amount_b >= amount_b_min, "AedexV2Router: INSUFFICIENT_B_AMOUNT")
        (amount_a,amount_b)

    payable stateful entrypoint remove_liquidity_ae(
            token: IAEX9Minimal
            , liquidity: int
            , amount_token_min: int
            , amount_ae_min: int
            , to: address
            , deadline: int
        ): (amount_token * amount_ae) =
        require_deadline(deadline)
        let (amount_token, amount_ae) = remove_liquidity(
                token, state.wae_aex9,
                liquidity,
                amount_token_min, amount_ae_min,
                Contract.address,
                deadline
                )
        token.transfer(to,amount_token)
        //TODO: be sure is the right thing to do
        state.wae.withdraw(amount_ae)
        Chain.spend(to,amount_ae)
        (amount_token,amount_ae)



    // **** SWAP ****
    // requires the initial amount to have already been sent to the first pair
    stateful function _swap(
            amounts: list(int)
            , path: list(IAEX9Minimal)
            , _to: address
            , factory: IAedexV2Factory  // we pass it as parameter to save multiple state lookups
            , callback_opt: option(IAedexV2Callback)
        ): unit =
        switch((path,amounts))
            (input::output::_path,_::amount_out::_amounts) =>
                let (token0,_) = AedexV2Library.sort_tokens(input,output)
                let (amount0_out, amount1_out) = if (input == token0) (0, amount_out) else (amount_out, 0)
                let to = switch(_path)
                            [] => _to
                            (nexOutput::_) => AedexV2Library.pair_for(factory,output,nexOutput).address
                let pair: IAedexV2Pair = AedexV2Library.pair_for(factory,input,output)

                pair.swap(amount0_out, amount1_out, to,callback_opt)
                _swap(amount_out::_amounts,output::_path,_to,factory,callback_opt)
            (path,_) | List.length(path) =< 1 => ()
            _ => abort_invalid_amounts()

    stateful entrypoint swap_exact_tokens_for_tokens(
              amount_in: int
            , amount_out_min: int
            , path: list(IAEX9Minimal)
            , to: address
            , deadline: int
            , callback_opt: option(IAedexV2Callback)
        ): list(int) =
        require_deadline(deadline)
        let factory = state.factory
        let amounts = AedexV2Library.get_amounts_out(factory, amount_in, path)
        require( last(amounts) >= amount_out_min,
                 "AedexV2Router: INSUFFICIENT_OUTPUT_AMOUNT"
               )
        List.get(0,path).transfer_allowance(
            Call.caller,
            first_pair(factory,path).address,
            List.get(0,amounts)
            )
        _swap(amounts, path, to, factory, callback_opt)
        amounts

    stateful entrypoint swap_tokens_for_exact_tokens(
              amount_out: int
            , amount_in_max: int
            , path: list(IAEX9Minimal)
            , to: address
            , deadline: int
            , callback_opt: option(IAedexV2Callback)
        ): list(int) =
        require_deadline(deadline)
        let factory = state.factory
        let amounts = AedexV2Library.get_amounts_in(factory, amount_out, path)
        require(List.get(0,amounts) =< amount_in_max, "AedexV2Router: EXCESSIVE_INPUT_AMOUNT")
        List.get(0,path).transfer_allowance(
            Call.caller,
            first_pair(factory,path).address,
            List.get(0,amounts)
            )
        _swap(amounts, path, to, factory, callback_opt)
        amounts

    payable stateful entrypoint swap_exact_ae_for_tokens(
              amount_out_min: int
            , path: list(IAEX9Minimal)
            , to: address
            , deadline: int
            , callback_opt: option(IAedexV2Callback)
        ): list(int) =
        require_deadline(deadline)
        let (wae,factory) = (state.wae,state.factory)
        require(first(path).address == wae.address, "AedexV2Router: INVALID_PATH_FIRST")
        let amounts = AedexV2Library.get_amounts_out(factory, Call.value, path)
        require(last(amounts) >= amount_out_min,
                 "AedexV2Router: INSUFFICIENT_OUTPUT_AMOUNT")
        let pair = first_pair(factory,path)
        wae.deposit_to(pair.address,value=List.get(0,amounts))
        _swap(amounts, path, to, factory, callback_opt )
        amounts

    stateful entrypoint swap_tokens_for_exact_ae(
              amount_out: int
            , amount_in_max: int
            , path: list(IAEX9Minimal)
            , to: address
            , deadline: int
            , callback_opt: option(IAedexV2Callback)
        ): list(int) =
        require_deadline(deadline)
        let (wae,factory) = (state.wae,state.factory)
        require(last(path).address == state.wae.address, "AedexV2Router: INVALID_PATH_LAST")
        let amounts = AedexV2Library.get_amounts_in(factory, amount_out, path)
        require(List.get(0,amounts) =< amount_in_max, "AedexV2Router: EXCESSIVE_INPUT_AMOUNT")
        List.get(0,path).transfer_allowance(
            Call.caller,
            first_pair(factory,path).address,
            List.get(0,amounts)
            )
        _swap(amounts, path, Contract.address, factory, callback_opt)
        let last_amount = last(amounts)
        wae.withdraw(last_amount)
        Chain.spend(to,last_amount)
        amounts

    stateful entrypoint swap_exact_tokens_for_ae(
          amount_in: int
        , amount_out_min: int
        , path: list(IAEX9Minimal)
        , to: address
        , deadline: int
        , callback_opt: option(IAedexV2Callback)
        ): list(int) =
        require_deadline(deadline)
        let (wae,factory) = (state.wae,state.factory)
        require(last(path).address == wae.address, "AedexV2Router: INVALID_PATH_LAST")
        let amounts = AedexV2Library.get_amounts_out(factory, amount_in, path)
        require(last(amounts)>= amount_out_min, "AedexV2Router: INSUFFICIENT_OUTPUT_AMOUNT")
        first(path).transfer_allowance(
            Call.caller,
            first_pair(factory,path).address,
            first(amounts)
            )
        _swap(amounts, path, Contract.address, factory, callback_opt)
        let last_amount = last(amounts)
        wae.withdraw(last_amount)
        Chain.spend(to,last_amount)
        amounts

    payable stateful entrypoint swap_ae_for_exact_tokens(
              amount_out: int
            , path: list(IAEX9Minimal)
            , to: address
            , deadline: int
            , callback_opt: option(IAedexV2Callback)
        ): list(int) =
        require_deadline(deadline)
        let (wae,factory) = (state.wae,state.factory)
        require(first(path).address == wae.address, "AedexV2Router: INVALID_PATH_FIRST")
        let amounts = AedexV2Library.get_amounts_in(factory, amount_out, path)
        let fst_amount = first(amounts)
        require(first(amounts) =< Call.value, "AedexV2Router: EXCESSIVE_INPUT_AMOUNT")
        let fst_pair = first_pair(factory,path)
        wae.deposit_to(fst_pair.address,value=fst_amount)
        _swap(amounts, path, to, factory, callback_opt)
        if (Call.value > fst_amount)
            Chain.spend(Call.caller,Call.value - fst_amount) // refund dust ae, if any
        amounts

    // **** LIB EXPOSURE ****
    entrypoint quote(amount_a, reserve_a, reserve_b ) =
        AedexV2Library.quote(amount_a, reserve_a, reserve_b)

    entrypoint get_amount_out( amount_in, reserve_in, reserve_out) =
        AedexV2Library.get_amount_out( amount_in, reserve_in, reserve_out)

    entrypoint get_amount_in( amount_out, reserve_in, reserve_out) =
        AedexV2Library.get_amount_in( amount_out, reserve_in, reserve_out)

    entrypoint get_amounts_out( amount_in , path) =
        AedexV2Library.get_amounts_out(state.factory, amount_in , path)

    entrypoint get_amounts_in( amount_out , path) =
        AedexV2Library.get_amounts_in(state.factory, amount_out , path)

    // **** UTILS ****
    function first_pair( factory: IAedexV2Factory, path: list(IAEX9Minimal)): IAedexV2Pair =
        AedexV2Library.pair_for(factory, List.get(0,path), List.get(1,path))

    function last(xs: list('a)): 'a = List.get(List.length(xs)-1,xs)
    function first(xs: list('a)): 'a = List.get(0,xs)

    function require_deadline(deadline: int) =
        require(deadline >= Chain.timestamp, "AedexV2Router: EXPIRED")
    function abort_invalid_amounts() =
        abort("AedexV2Router: AMOUNT_LIST_IS_SHORTER")

