@compiler >= 6

include "./lib/Utils.aes"

//TODO:
// 1. add extension of AEX9?

include "./interfaces/IAEX9Minimal.aes"
contract AedexV2Pair =
    type owner = address
    type spender = address

    datatype event 
        = Transfer(address /*indexed from*/, address /*indexed to*/, int /*value*/)
        | Approval(address /*indexed owner*/, address /*indexed spender*/, int /*value*/)
        | Allowance(address /*indexed owner*/, address /*indexed spender*/, int /*value*/)

        | Mint(address /*indexed sender*/, int /*amount0*/, int /*amount1*/)
        | Burn(address /*indexed sender*/, address /*indexed to*/, string /*int amount0 | int amount1*/ )
        | Swap(
            address /*indexed sender*/
            , address /*indexed to*/
            , string
            /*
            , uint amount0In,
            , uint amount1In,
            , uint amount0Out,
            , uint amount1Out,
            */
        )
        | Sync(int /*uint112 reserve0*/, int /*reserve1*/)

    record state = {
              //token area
              total_supply: int
            , balance_of: map(owner, int)
            , allowance: map(owner, map(spender,int))
            , factory: IAedexV2Factory 
            , token0: IAEX9Minimal 
            , token1: IAEX9Minimal 
            , reserve0: int           // uses single storage slot, accessible via getReserves
            , reserve1: int           // uses single storage slot, accessible via getReserves
            , blockTimestampLast: int  // uses single storage slot, accessible via getReserves
            , price0CumulativeLast: int
            , price1CumulativeLast: int
            , kLast: int // reserve0 * reserve1, as of immediately after the most recent liquidity event
            , unlocked: int
            }

    entrypoint init (
          factory: IAedexV2Factory 
        , token0: IAEX9Minimal 
        , token1: IAEX9Minimal 
        ) = {
              total_supply = 0
            , balance_of   = {}
            , allowance    = {}
            , factory = factory 
            , token0 = token0 
            , token1 = token1 
            , reserve0 = 0           
            , reserve1 = 0           
            , blockTimestampLast = 0  
            , price0CumulativeLast = 0
            , price1CumulativeLast = 0
            , kLast = 0 
            , unlocked = 1
        }

    //AEX9 PART

    stateful function _mint(to: address,value: int) = 
        AE.validate_positive(value)
        put(state { total_supply @ p = p + value
                  , balance_of[ to = 0] @ p = p + value
                  })
        //TODO: be sure Contract.address represents the owner of the liquidity coin
        Chain.event( Transfer(Contract.address, to, value) )

    stateful function _burn(from: address,value: int) = 
        AE.validate_positive(value)
        put(state { total_supply @ p = p - value
                  , balance_of[ from = 0] @ p = p - value
                  })
        //TODO: be sure Contract.address represents the owner of the liquidity coin
        Chain.event( Transfer(from, Contract.address, value) )

    entrypoint meta_info(): IAEX9Minimal.meta_info = {
          name = "Aedex  v2",
          symbol = "AEDX-V2",
          decimals = 18
        }

    entrypoint total_supply() = state.total_supply

    entrypoint balance(address: address): option(int) = 
        //we replace None with 0
        Some(Map.lookup_default(address,state.balance_of,0))

    /*stateful entrypoint allowance(owner: address, spender: address): AE.uint256 = */
    entrypoint allowance(accounts: IAEX9Minimal.allowance_accounts): option(int) = 
        let (owner,spender) = (accounts.from_account,accounts.for_account)
        let spenderA = Map.lookup_default(owner,state.allowance,{})
        Map.lookup(spender,spenderA)

    stateful function _create_allowance(owner: address,spender: address, amount: int): unit =
        AE.validate_positive(amount)
        let old = Map.lookup_default(owner,state.allowance,{})
        put( state { allowance @ x = x { [owner] = old { [spender] = amount } } } )
        Chain.event( Allowance(owner, spender, amount) )

    stateful entrypoint create_allowance(spender: address, amount: int): unit =
        _create_allowance(Call.caller,spender,amount)

    stateful entrypoint transfer(recipient: address , amount: int): unit =
        AE.validate_positive(amount)
        let balance_before = Map.lookup_default(Call.caller,state.balance_of,0)
        require(balance_before >= amount, String.concat( "insufficient balance for: ",Address.to_str(Call.caller)))
        if(Call.caller != recipient) 
            let balance_recipient = Map.lookup_default(recipient,state.balance_of,0)

            put(state { balance_of @ b = b 
                            { [Call.caller] = balance_before - amount
                            , [recipient] = balance_recipient + amount
                            }
                      }
               )
            Chain.event( Transfer(Call.caller, recipient, amount) )

    stateful entrypoint transfer_allowance(sender: address, recipient: address, amount: int) = 
        AE.validate_positive(amount)
        let allowance_before = Map.lookup_default(
                Call.caller,
                Map.lookup_default(sender,state.allowance,{}),
                0
                )

        require(allowance_before >= amount, String.concat("allowance insufficient: ",Address.to_str(Call.caller)))

        let balance_recipient = Map.lookup_default(
             recipient,
             state.balance_of,
             0
             )
        let balance_sender = Map.lookup_default( sender, state.balance_of,0 )
        require(balance_sender >= amount, "underflow balance sender")

        put(state
            { allowance @ a = a { [sender] @ s = s {[Call.caller] = allowance_before - amount }}
            , balance_of @ b = b { [recipient] = balance_recipient + amount
                                , [sender] = balance_sender - amount
                                }
            })
        
        Chain.event( Transfer(sender, recipient, amount) )

    stateful entrypoint permit(
            owner: address
            , spender: address
            , value: int
            , deadline: int
            /*, uint8 v*/
            /*, bytes32 r*/
            /*, bytes32 s*/
            ) =
        require(deadline >= Chain.timestamp, "AedexV2: EXPIRED")
        //TODO: replace this with aeternity equivalent if there is such a thing
        //WARNING: the owner is not the Call.caller ????!!!!!
        // should we replace the owner with Call.caller

        /*bytes32 digest = keccak256(*/
            /*abi.encodePacked(*/
                /*'\x19\x01',*/
                /*DOMAIN_SEPARATOR,*/
                /*keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))*/
            /*)*/
        /*);*/
        /*address recoveredAddress = ecrecover(digest, v, r, s);*/
        /*require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');*/
        _create_allowance(owner,spender,value)

