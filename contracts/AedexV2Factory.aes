@compiler >= 6

include "List.aes"
include "Option.aes"
include "./interfaces/IAedexV2Pair.aes"
include "./interfaces/IAedexV2FactoryForPair.aes"

contract AedexV2Factory =
    record state = {
              fee_to: option(address)
            , fee_to_setter: address
            , pairs: map(IAEX9Minimal,map(IAEX9Minimal,IAedexV2Pair))
            , all_pairs: list(IAedexV2Pair)
            , pair_model: IAedexV2Pair
            , allow_debug_mode: bool
            }

    datatype event
        = PairCreated(
                  address /*indexed token0*/
                , address /*indexed token1*/
                , address /*pair*/
                , string /*uint*/
                )

    //WARNING: use allow_debug_mode (= Some(true)) only in development.
    //Never initialize a factory in production/mainnet with debug_mode activated
    entrypoint init(
        fee_to_setter: address
        , pair_model: IAedexV2Pair
        , allow_debug_mode: option(bool)
        ) = { fee_to           = None
            , fee_to_setter    = fee_to_setter
            , pairs            = {}
            , all_pairs        = []
            , pair_model       = pair_model
            , allow_debug_mode = Option.default(false,allow_debug_mode)
            }

    entrypoint all_pairs_length(): int = List.length(state.all_pairs)
    entrypoint all_pairs(ix: int): IAedexV2Pair = List.get(ix,state.all_pairs)
    entrypoint fee_to() = state.fee_to
    entrypoint fee_to_setter() = state.fee_to_setter
    entrypoint allow_debug_mode() = state.allow_debug_mode
    entrypoint get_pair(
          token_a: IAEX9Minimal
        , token_b: IAEX9Minimal
        ): option(IAedexV2Pair) =
        let (token0,token1) = sort_tokens(token_a,token_b)
        switch(Map.lookup(token0,state.pairs))
            None => None
            Some(m) => Map.lookup(token1,m)

    function validate_fee_to_setter() =
        require(Call.caller == state.fee_to_setter, "AedexV2Factory: FORBIDDEN")

    stateful entrypoint set_fee_to(fee_to: address) =
        validate_fee_to_setter()
        put( state { fee_to = Some(fee_to)})

    stateful entrypoint set_fee_to_setter(fee_to_setter: address) =
        validate_fee_to_setter()
        put( state { fee_to_setter = fee_to_setter})

    function sort_tokens(token_a: IAEX9Minimal,token_b: IAEX9Minimal) =
        if(token_a.address < token_b.address)
            (token_a,token_b)
        else
            (token_b,token_a)

    stateful entrypoint create_pair(
          token_a: IAEX9Minimal
        , token_b: IAEX9Minimal
        , min_liquidity: option(int) // the minimum liquidity constant for the pair
                                     // see AedexV2Pair `init` description for more information
                                     // about the default value
        , debug_time: option(int)
        ): IAedexV2Pair =

        require(token_a != token_b, "AedexV2Factory: IDENTICAL_ADDRESSES")
        let (token0,token1) = sort_tokens(token_a,token_b)

        let has_old_value =
                Map.member(
                    token1,
                    Map.lookup_default(token0,state.pairs,{})
                    )
        require(!has_old_value,"AedexV2Factory: PAIR_EXISTS")
        require(state.allow_debug_mode || Option.is_none(debug_time),"AedexV2Factory: NOT_DEBUG_MODE")
        let pair = Chain.clone(
                    ref=state.pair_model
                    , Address.to_contract( Contract.address )
                    , token0
                    , token1
                    , min_liquidity
                    , debug_time
                    )


        let update_token0_map = (p: map(IAEX9Minimal,map(IAEX9Minimal,IAedexV2Pair))) =>
            let old_t0_map: map(IAEX9Minimal,IAedexV2Pair) = Map.lookup_default(token0,p,{})
            old_t0_map { [token1] = pair }

        let new_all_pairs = pair::state.all_pairs
        put( state { pairs @ p = p { [token0] = update_token0_map(p) }
                   , all_pairs = new_all_pairs
                   })
        Chain.event( PairCreated(
              token0.address
            , token1.address
            , pair.address
            , Int.to_str(List.length(new_all_pairs))
            ))
        pair

