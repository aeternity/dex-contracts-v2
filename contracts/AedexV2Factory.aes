@compiler >= 6

include "List.aes"
include "Option.aes"
include "./interfaces/IAedexV2Pair.aes"
include "./interfaces/IAedexV2FactoryForPair.aes"

contract AedexV2Factory =
    type tokenIdPair = (IAEX9Minimal*IAEX9Minimal)
    record state = {
              fee_to: option(address)
            , fee_to_setter: address
            , pairs: map(tokenIdPair, IAedexV2Pair)
            , all_pairs: list(IAedexV2Pair)
            , pair_model: IAedexV2Pair
            , allow_debug_mode: bool
            }

    datatype event
        = PairCreated(
                  address /*indexed token0*/
                , address /*indexed token1*/
                , address /*pair*/
                , string /*uint*/
                )

    //WARNING: use allow_debug_mode (= Some(true)) only in development.
    //Never initialize a factory in production/mainnet with debug_mode activated
    entrypoint init(
          fee_to_setter: address
        , pair_model: IAedexV2Pair
        , allow_debug_mode: option(bool)
        ) = { fee_to           = None
            , fee_to_setter    = fee_to_setter
            , pairs            = {}
            , all_pairs        = []
            , pair_model       = pair_model
            , allow_debug_mode = Option.default(false, allow_debug_mode)
            }

    entrypoint all_pairs_length(): int = List.length(state.all_pairs)

    entrypoint all_pairs(ix: int): IAedexV2Pair = List.get(ix, state.all_pairs)

    entrypoint fee_to() = state.fee_to

    entrypoint fee_to_setter() = state.fee_to_setter

    entrypoint allow_debug_mode() = state.allow_debug_mode

    entrypoint get_pair(
          token_a: IAEX9Minimal
        , token_b: IAEX9Minimal
        ): option(IAedexV2Pair) =
        Map.lookup(sort_tokens(token_a, token_b), state.pairs)

    function validate_fee_to_setter() =
        require(Call.caller == state.fee_to_setter, "AedexV2Factory: FORBIDDEN")

    stateful entrypoint set_fee_to(fee_to: option(address)) =
        validate_fee_to_setter()
        put(state { fee_to = fee_to })

    stateful entrypoint set_fee_to_setter(fee_to_setter: address) =
        validate_fee_to_setter()
        put(state { fee_to_setter = fee_to_setter })

    function sort_tokens(token_a: IAEX9Minimal, token_b: IAEX9Minimal) =
        if(token_a.address < token_b.address)
            (token_a, token_b)
        else
            (token_b, token_a)

    stateful entrypoint create_pair(
          token_a: IAEX9Minimal
        , token_b: IAEX9Minimal
        , min_liquidity: option(int) // the minimum liquidity constant for the pair
                                     // see AedexV2Pair `init` description for more information
                                     // about the default value
        , debug_time: option(int)
        ): IAedexV2Pair =

        require(token_a != token_b, "AedexV2Factory: IDENTICAL_ADDRESSES")
        let (token0, token1) = sort_tokens(token_a, token_b)

        let has_old_value = Map.member((token0, token1), state.pairs)

        require(!has_old_value, "AedexV2Factory: PAIR_EXISTS")
        require(state.allow_debug_mode || Option.is_none(debug_time), "AedexV2Factory: NOT_DEBUG_MODE")
        let pair = Chain.clone(
                      ref=state.pair_model
                    , Address.to_contract( Contract.address )
                    , token0
                    , token1
                    , min_liquidity
                    , debug_time
                    )

        let new_all_pairs = pair::state.all_pairs
        put( state { pairs[(token0, token1)] = pair
                   , all_pairs = new_all_pairs
                   })
        Chain.event( PairCreated(
              token0.address
            , token1.address
            , pair.address
            , Int.to_str(List.length(new_all_pairs))
            ))
        pair

